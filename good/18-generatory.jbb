
// fun square(var begin: Integer, var end: Integer) : Gen[Integer] {
//     for i = begin..end {
//         yield i * i;
//     }
// }

// val g: Gen[Integer] = square(1, 10);
// while hasNext(g) {
//     writeInt(next(g));
// }
// // wypisze "1", "4", "9", "16", "25", "36", "49", "64", "81", "100", "0"


// val g: Gen[Integer] = square(1, 10);
// for i in g {
//     writeInt(i);
// }
// // wypisze "1", "4", "9", "16", "25", "36", "49", "64", "81", "100"
// // ponieważ for-generator jest mądrzejszy niż while-generator

// fun progres(val n: Integer) : Gen[Unit] {
//     for i = 1..n {
//         writeStr("Progres: ");
//         writeInt(i);
//         writeStr(" / ");
//         writeInt(n);
//         writeStr("\n");
//         yield;
//     }
// }

// val p: Gen[Unit] = progres(3);

// val x: Integer = dluuuuga_funkcja();
// next(p);
// // wypisze "Progres: 1 / 3"

// val x: Integer = dluuuuga_funkcja();
// next(p);
// // wypisze "Progres: 2 / 3"

// val x: Integer = dluuuuga_funkcja();
// next(p);
// // wypisze "Progres: 3 / 3"

// hasNext(p); // true
// next(p); // wyjście poza pętle, dojście do końca funkcji
// hasNext(p); // false



// // Generatory to dosyć śliski temat, więc na razie są dosyć ograniczone.
